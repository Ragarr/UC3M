# -*- coding: utf-8 -*-
"""Dijkstra.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fayvUagce1YweRFY-Iqy5Py-EOy9nag1

# Dijkstraâ€™s shortest path algorithm

This tool (https://graphonline.ru/en/) can help you to check if your solutions are right.



First, we need to load a python file containing the implementation of a graph (graphdictionarywd.py).

You can download from
https://github.com/isegura/EDA/blob/master/graph.py
"""

"""## Shortest path algorithm"""




import sys
from implementaciones.graph import Graph

class GraphDijkstra(Graph):

    def minDistance(self, distances, visited):
        """This functions returns the vertex (index) whose associated value in
        the dictionary distances is the smallest value. We 
        only consider the set of vertices that have not been visited"""
        # la minima distancia sera infinito por defecto
        min = sys.maxsize

        # buscamos cual es el vertice NO VISITADO mas cercano AL ORIGEN
        for vertex in self._vertices.keys():
            if distances[vertex] <= min and visited[vertex] == False:
                min = distances[vertex]  # update the new smallest
                min_vertex = vertex  # update the index of the smallest

        return min_vertex

    def dijkstra(self, origin):
        """"This function takes a vertex v and calculates its mininum path 
        to the rest of vertices by using the Dijkstra algoritm"""

        # visisted is a dictionary whose keys are the verticies of our graph.
        # When we visite a vertex, we must mark it as True.
        # Initially, all vertices are defined as False (not visited)
        visited = {}
        for v in self._vertices.keys():
            visited[v] = False

        # this dictionary will save the previous vertex for the key in the minimum path
        previous = {}
        for v in self._vertices.keys():
            # initially, we defines the previous vertex for any vertex as None
            previous[v] = None

        # This distance will save the accumulate distance from the
        # origin to the vertex (key)
        distances = {}
        for v in self._vertices.keys():
            distances[v] = sys.maxsize

        # The distance from origin to itself is 0
        distances[origin] = 0

        for n in range(len(self._vertices)):
            # Pick the vertex with the minimum distance vertex.
            # u is always equal to origin in first iteration

            # Seleccionamos el vertice mas cercano al vertice actual, con la condicion de que no se haya visitado
            # en la primera iteracion como origen no esta visitado y 
            # la distancia del origen al vertice actual (que es origen) es 0 u sera = origin
            u = self.minDistance(distances, visited)
            
            # marcamos el vertice actual como visitado para no volver a visitarlo
            visited[u] = True


            # vamos a recorrer los vertices adjacecentes al vertice actual u, para actualizar su distancia
            # al origen unicamente si la distancia actual es mayor que la nueva distancia
            for adj in self._vertices[u]:
                i = adj._vertex
                w = adj._weight
                if visited[i] == False and distances[i] > distances[u]+w:
                    # tenemos que comprobar que no esta visitado el vertice ya que si esta
                    # visitado no se actualiza la distancia para no dar vueltas en circulos

                    # actualizamos la distancia del vertice actual al origen
                    distances[i] = distances[u]+w
                    previous[i] = u

        # finally, we print the minimum path from origin to the other vertices
        self.printSolution(distances, previous, origin)

    def printSolution(self, distances, previous, origin):
        print("Mininum path from ", origin)

        for i in self._vertices.keys():
            if distances[i] == sys.maxsize:
                print("There is not path from ", origin, ' to ', i)
            else:

                # minimum_path is the list wich contains the minimum path from origin to i
                minimum_path = []
                prev = previous[i]
                # this loop helps us to build the path
                while prev != None:
                    minimum_path.insert(0, prev)
                    prev = previous[prev]

                # we append the last vertex, which is i
                minimum_path.append(i)

                # we print the path from v to i and the distance
                print(origin, '->', i, ":", minimum_path, distances[i])


"""Now, we use the implementation to represent this graph: 

<img src='https://upload.wikimedia.org/wikipedia/commons/thumb/b/bc/CPT-Graphs-directed-weighted-ex1.svg/722px-CPT-Graphs-directed-weighted-ex1.svg.png' width='25%'/>
"""
if __name__ == '__main__':

    # we use this dictionary to represent the vertices with numbers:
    labels = ['A', 'B', 'C', 'D', 'E']

    g = GraphDijkstra(labels)

    # Now, we add the edges
    g.addEdge('A', 'C', 12)  # A->(12)C
    g.addEdge('A', 'D', 60)  # A->(60)D
    g.addEdge('B', 'A', 10)  # B->(10)A
    g.addEdge('C', 'B', 20)  # C->(20)B
    g.addEdge('C', 'D', 32)  # C->(32)D
    g.addEdge('E', 'A', 7)  # E->(7)A

    print(g)

    g.dijkstra('A')

    """## Exercise: 

    Calculate the minimum path from a to the rest of the vertices in this graph:

    <img src='https://www.bogotobogo.com/python/images/Dijkstra/graph_diagram.png' src='25%'/>
    """

    # we use this dictionary to represent the vertices with numbers:

    labels = ['a', 'b', 'c', 'd', 'e', 'f']

    g = GraphDijkstra(labels, False)

    # Now, we add the edges
    g.addEdge('a', 'b', 7)
    g.addEdge('a', 'c', 9)
    g.addEdge('a', 'f', 14)
    g.addEdge('b', 'c', 10)
    g.addEdge('b', 'd', 15)
    g.addEdge('c', 'd', 11)
    g.addEdge('c', 'f', 2)
    g.addEdge('d', 'e', 6)
    g.addEdge('e', 'f', 9)

    print(g)

    g.dijkstra('a')

    g.dijkstra('f')

    g.dijkstra('b')

    """## Exercise

    Use the previous implementation to obtain the mininum path from X to Y in this graph:

    <img src='http://benalexkeen.com/wp-content/uploads/2017/01/Dijkstra.png'>
    """
