# -*- coding: utf-8 -*-
"""Graph-ListAdjacencyWD.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wFfEI8eOAV_6c-6kIEemNObYaSC5jsd3

# Graph representation based on adjacency List 

The idea is to represent the adjacent vertices of a given vertex using a linked list (though you could also use a Python list)

<img src='https://ucarecdn.com/a67cb888-aa0c-424b-8c7f-847e38dd5691/' width='50%'/>


To simplify this implementation, we assume that the labels of the vertices are numbers from 0, 1, 2,...

First, you must load the python file named dlist.py containing our implementaton of doubly linked list. You can download from:

https://github.com/isegura/EDA/blob/master/dlist.py
"""

from dlist import DList

class AdjacentVertex:
    """This class allows us to represent a tuple with an adjacent vertex
    and the weight associated (by default 1, for non-unweighted graphs)"""
    def __init__(self,vertex,weight=None):
        self._vertex=vertex
        self._weight=weight
    
    def __str__(self):
        if self._weight!=None:
            return '('+str(self._vertex)+','+str(self._weight)+')'
        else:
            return str(self._vertex)

class Graph():
    """This implementation is based on adjacency lists."""
    def __init__(self,vertices,directed=True):
        """This constructor gets an array saving the vertices. The class has the
        following attributes:
        _vertices: is a Python list to save the vertices
        _adjacents: a Python list of doubly linked list. 
        Given a vertex v, it has an index in _vertices, for example, i. 
        Then, its list of adjacent vertex is saved into _adjacents[i], which is a 
        doubly linked list saving objects of the AdjacentVertex class.  
        """
        self._vertices =vertices
        self._adjacents=[]
        for v in self._vertices:
            self._adjacents.append(DList())

        self._directed=directed
        
    def addVertex(self,v):
        self._vertices.append(v)
        self._adjacents.append(DList())
        self._N+=1


    def _index(self,v):
        try:
            index=self._vertices.index(v)
        except:
            index=-1
        return index

     
    def addEdge(self, start, end, weight=None):
        """This function adds the edge (start,end). First, it must check if the 
        vertices exist."""
        i,j=self._index(start),self._index(end)
        if i==-1:
            print('[addEdge]: {} does not exist!!!'.format(start))
            return
        if j==-1:
            print('[addEdge]: {} does not exist!!!'.format(end))
            return


        self._adjacents[i].addLast(AdjacentVertex(end,weight))
        if self._directed==False:
            self._adjacents[j].addLast(AdjacentVertex(start,weight))

        
                
    def containsEdge(self, start, end):
        """This function adds the edge (start,end). First, it must check if the 
        vertices exist."""
        i,j=self._index(start),self._index(end)
        if i==-1:
            print('[containsEdge]: {} does not exist!!!'.format(start))
            return 0
        if j==-1:
            print('[containsEdge]: {} does not exist!!!'.format(end))
            return 0
        for k in range(len(self._adjacents[i])):
            adj=self._adjacents[i].getAt(k)   
            if adj._vertex==end:
                if adj._weight==None:
                    return 1
                else:
                    return adj._weight

        return 0


    def removeEdge(self, start, end):
        """This function adds the edge (start,end). First, it must check if the 
        vertices exist."""
        i,j=self._index(start),self._index(end)
        if i==-1:
            print('[removeEdge]: {} does not exist!!!'.format(start))
            return 
        if j==-1:
            print('[removeEdge]: {} does not exist!!!'.format(end))
            return 

        for k in range(len(self._adjacents[i])):
            adj=self._adjacents[i].getAt(k)   
            if adj._vertex==end:
                self._adjacents[i].removeAt(k)
                break

        if not self._directed:
            for k in range(len(self._adjacents[j])):
                adj=self._adjacents[j].getAt(k)   
                if adj._vertex==start:
                    self._adjacents[j].removeAt(k)
                    break

        
    def __str__(self):
        result=''
        for i,v in enumerate(self._vertices):
            result+='\n'+str(v)+': '+str(self._adjacents[i])
        return result

"""Now, we use the implementation to represent this  undirected graph: 

<img src='https://i.stack.imgur.com/31ml3.png' width='50%'/>
"""
if __name__ == '__main__':

    #we use this dictionary to represent the vertices with numbers:
    labels=[0,1,2,3,4]
    g=Graph(labels,False)
    print(g)

    #Now, we add the edges
    g.addEdge(0,1)
    g.addEdge(0,4)
    g.addEdge(1,2)
    g.addEdge(1,3)
    g.addEdge(1,4)
    g.addEdge(2,3)
    g.addEdge(3,4)
    print(g)

    print()
    print('g.containsEdge({},{})={}'.format(0,1,g.containsEdge(0,1)))
    print('g.containsEdge({},{})={}'.format(1,0,g.containsEdge(1,0)))

    print('g.containsEdge({},{})={}'.format(3,1,g.containsEdge(3,1)))
    print('g.containsEdge({},{})={}'.format(0,2,g.containsEdge(0,2)))


    print(g)
    g.removeEdge(2,3)
    print(g)

    """Now, we represent this weighted graph:
    https://hyperskill.org/learn/step/5645

    <img src='https://ucarecdn.com/a67cb888-aa0c-424b-8c7f-847e38dd5691/' width=25%>
    """

    #we use this dictionary to represent the vertices with numbers:
    labels=[0,1,2,3,4]
    g=Graph(labels,False)

    #Now, we add the edges
    g.addEdge(0,1,3)
    g.addEdge(0,3,7)
    g.addEdge(0,4,8)
    g.addEdge(1,2,1)
    g.addEdge(1,3,4)
    g.addEdge(2,3,2)
    g.addEdge(3,4,3)
    print(g)
    print()
    print('g.containsEdge({},{})={}'.format(0,1,g.containsEdge(0,1)))
    print('g.containsEdge({},{})={}'.format(1,0,g.containsEdge(1,0)))

    print('g.containsEdge({},{})={}'.format(3,1,g.containsEdge(3,1)))
    print('g.containsEdge({},{})={}'.format(0,2,g.containsEdge(0,2)))



    print(g)
    print()
    print('after removing (2,3):')
    g.removeEdge(2,3)
    print(g)

    """Now, we use the implementation to represent this graph: 

    <img src='https://upload.wikimedia.org/wikipedia/commons/thumb/b/bc/CPT-Graphs-directed-weighted-ex1.svg/722px-CPT-Graphs-directed-weighted-ex1.svg.png' width='25%'/>
    """

    labels=['A','B','C','D','E']

    g=Graph(labels)

    #Now, we add the edges
    g.addEdge('A','C',12) 
    g.addEdge('A','D',60)
    g.addEdge('B','A',10) 
    g.addEdge('C','B',20)
    g.addEdge('C','D',32) 
    g.addEdge('E','A',7) 

    print(g)
    print()
    print("g.containsEdge('C','B')", g.containsEdge('C','B'))
    print(g.containsEdge('B','C'))


    g.removeEdge('C','B')
    print('after removing (C,E)')
    print(g)