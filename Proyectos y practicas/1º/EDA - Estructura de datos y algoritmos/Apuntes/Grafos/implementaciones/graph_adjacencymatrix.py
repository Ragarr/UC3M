# -*- coding: utf-8 -*-
"""Graph-AdjacencyMatrix.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AOXWLRkbf4T2lQVef4ot3982ccVeAk4z

## Gran implementation based on an adjacency Matrix 
A graph can be represented using an adjacency matrix. In this tutorial, we see how to learn to implement graphs based on adjacency matrices. We focus on directed and unweighted graph
"""

class Graph(object):
    """This is an implementation for an unweighted and undirected graph based on an adjacency matrix"""
    def __init__(self,vertices):
        """This constructors gets a Python list of vertices and creates an empty adjacency matrix  """
        #labels is the set of vertices, for example, A, B, C, D...
        self._vertices=vertices

        N=len(vertices)
        #we initializae the matrix with 0s
        self._matrix = [ [ 0 for i in range(N) ] for j in range(N) ]
    
    def _index(self,v):
        """gets a vertex and returs its index. If v does not exist, 
		it shows an error message and returns -1"""
        try:
            index=self._vertices.index(v)
        except:
            print(v,' is not a vertex!!!')
            index=-1
        return index

    def addEdge(self,start,end):
        """gets two vertices and adds an edge from start to end."""
        #first, we get their indeces
        i,j=self._index(start),self._index(end)
        if i==-1:
            print('[addEdge]: {} does not exist!!!'.format(start))
            return
        if j==-1:
            print('[addEdge]: {} does not exist!!!'.format(end))
            return
        #now, we modify its element in the matrix 
        self._matrix[i][j]=1
        print('[addEdge]: ({},{}) was added!!!'.format(start,end))

    def containEdge(self,start,end):
        """checks if the edge from start to end exists."""
        i,j=self._index(start),self._index(end)
        if i==-1:
            print('[containEdge]: {} does not exist!!!'.format(start))
            return False
        if j==-1:
            print('[containEdge]: {} does not exist!!!'.format(end))
            return False
            
        return self._matrix[i][j]==1
    
    def removeEdge(self,start,end):
        """removes the edge from start to end. It must
        modify its corresponding element in the matrix to 0."""
        i,j=self._index(start),self._index(end)
        if i==-1:
            print('[removeEdge]: {} does not exist!!!'.format(start))
            return 
        if j==-1:
            print('[removeEdge]: {} does not exist!!!'.format(end))
            return 
		
        self._matrix[i][j]=0
    
    def __str__(self):
        """returns the matrix"""
        result=' '
        #the first row are the vertices
        for l in self._vertices:
            result+='  ' + l
        
        result+='\n'
    
        for i,row in enumerate(self._matrix):
            result+=self._vertices[i]+' ' +str(row)+'\n'
        
        return result

"""Now, we use the implementation to represent this directed and unweighted graph:


<img src='https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Directed_graph%2C_cyclic.svg/900px-Directed_graph%2C_cyclic.svg.png' width='35%'/>
"""
if __name__ == '__main__':

    vertices=['A','B','C','D','E','F']

    g=Graph(vertices)

    #Now, we add the edges
    g.addEdge('A','B') #A->B
    g.addEdge('B','C') #B->C
    g.addEdge('C','E') #C->E
    g.addEdge('D','B') #D->B
    g.addEdge('E','D') #E->D
    g.addEdge('E','F') #E->D
    print('containEdge(A,E)=',g.containEdge('A','E'))
    print('containEdge(D,B)=',g.containEdge('D','B'))

    print(g)

    g.removeEdge('E','D')
    print(g)

    """##Exercise:

    The previous implementation allows us to represent unweighted and directed graphs. 

    Please, extend it to also represent weighted and undirected graphs.
    """
    


